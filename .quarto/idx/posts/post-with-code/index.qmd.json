{"title":"Robust SQL calls from Python","markdown":{"yaml":{"title":"Robust SQL calls from Python","author":"Dekel Wainer","date":"2025-05-29","categories":["SQL","Python","reliability"],"image":"image.png"},"headingText":"define this class in a helper module","containsRefs":false,"markdown":"\n\nMaking Python code interact with an SQL database is straightforward.\nImagine you're using a cloud SQL and want to insert data into 2 tables. You might generate this code:\n\n```{python}\n#| eval: false\nimport os\nimport pyodbc\n\nconn_str = os.getenv(\"sql_connection_string\")  # secret connection string\n\nwith pyodbc.connect(conn_str) as conn:\n    with conn.cursor() as cursor:\n\n        insert_query = \"\"\"\n            INSERT INTO some_table (field1, field2, field3)  -- fieldN are the actual fields in the database\n            VALUES (?, ?, ?)\n        \"\"\"\n        cursor.execute(insert_query, (field1, field2, field3))  # fieldN here are the variables in Python\n        conn.commit()\n\n        insert_query = \"\"\"\n            INSERT INTO another_table (field4, field5)\n            VALUES (?, ?)\n        \"\"\"\n        cursor.execute(insert_query, (field4, field5)) \n        conn.commit()\n```\n\nA vibe-coding developer might stop here, assured by the LLM that this is good implementation because:\n    - The connection string isn't being exposed.\n    - Placeholders (the '?') are being used, which protects against SQL injection.\n    - A context manager is used (the 'with' statements), which automatically closes the connection to the SQL database.\n\nBut it's not good implementation, because there's no error handling.\nThis means any communication or schema error will result in unexpected behavior in the program.\nWorse still, if an error occurs after the first query is committed but the second isn't, your database only contains partial data.\n\nSo a better approach is to add explicit error handling, and commit data after all queries have succeeded.\nNothing gets committed unless everything runs smoothly.\n\n```{python}\n#| eval: false\ntry:\n    with pyodbc.connect(conn_str) as conn:\n        with conn.cursor() as cursor:\n            insert_query_1 = \"\"\"\n                INSERT INTO some_table (field1, field2, field3)\n                VALUES (?, ?, ?)\n            \"\"\"\n            cursor.execute(insert_query_1, (field1, field2, field3))\n\n            insert_query_2 = \"\"\"\n                INSERT INTO another_table (field4, field5)\n                VALUES (?, ?)\n            \"\"\"\n            cursor.execute(insert_query_2, (field4, field5))\n\n        # commit once\n        conn.commit()\n\nexcept Exception as e:\n    print(f\"Database operation failed: {e}\")\n    conn.rollback()\n```\n\nBut what if you don't have all the information needed to commit concurrently in a single script?\nFor instance, if your program collects data across dozens of scripts - there is no opportunity to commit everything at once.\n\nInstead, you can call a stable class into each relevant script, and append the query you want to commit.\nThen, at some later point in the program, you loop over that list and write the queries to the database.\n\n```{python}\n#| eval: false\nclass QueryCollector:\n    def __init__(self):\n        self.queries = []\n\n    def add(self, query, params):\n        self.queries.append((query, params))\n\n    def execute_all(self, conn_str):\n        try:\n            with pyodbc.connect(conn_str) as conn:\n                with conn.cursor() as cursor:\n                    for query, params in self.queries:\n                        cursor.execute(query, params)\n                conn.commit()\n        except Exception as e:\n            print(f\"Error during batched SQL execution: {e}\")\n            conn.rollback()\n\n\n# call the class in any script that needs it\ncollector = QueryCollector()\n\ncollector.add(\n    \"INSERT INTO some_table (field1, field2, field3) VALUES (?, ?, ?)\",\n    (field1, field2, field3)\n)\n\n\n# commit everything at a later point in the program, once you collected all your queries\ncollector.execute_all(os.getenv(\"sql_connection_string\"))\n```\n\nNow you have a centralized solution which is easy to expand. For example, you can add complex error handling, query-level logging, retries, or group commits to reduce I/O.”","srcMarkdownNoYaml":"\n\nMaking Python code interact with an SQL database is straightforward.\nImagine you're using a cloud SQL and want to insert data into 2 tables. You might generate this code:\n\n```{python}\n#| eval: false\nimport os\nimport pyodbc\n\nconn_str = os.getenv(\"sql_connection_string\")  # secret connection string\n\nwith pyodbc.connect(conn_str) as conn:\n    with conn.cursor() as cursor:\n\n        insert_query = \"\"\"\n            INSERT INTO some_table (field1, field2, field3)  -- fieldN are the actual fields in the database\n            VALUES (?, ?, ?)\n        \"\"\"\n        cursor.execute(insert_query, (field1, field2, field3))  # fieldN here are the variables in Python\n        conn.commit()\n\n        insert_query = \"\"\"\n            INSERT INTO another_table (field4, field5)\n            VALUES (?, ?)\n        \"\"\"\n        cursor.execute(insert_query, (field4, field5)) \n        conn.commit()\n```\n\nA vibe-coding developer might stop here, assured by the LLM that this is good implementation because:\n    - The connection string isn't being exposed.\n    - Placeholders (the '?') are being used, which protects against SQL injection.\n    - A context manager is used (the 'with' statements), which automatically closes the connection to the SQL database.\n\nBut it's not good implementation, because there's no error handling.\nThis means any communication or schema error will result in unexpected behavior in the program.\nWorse still, if an error occurs after the first query is committed but the second isn't, your database only contains partial data.\n\nSo a better approach is to add explicit error handling, and commit data after all queries have succeeded.\nNothing gets committed unless everything runs smoothly.\n\n```{python}\n#| eval: false\ntry:\n    with pyodbc.connect(conn_str) as conn:\n        with conn.cursor() as cursor:\n            insert_query_1 = \"\"\"\n                INSERT INTO some_table (field1, field2, field3)\n                VALUES (?, ?, ?)\n            \"\"\"\n            cursor.execute(insert_query_1, (field1, field2, field3))\n\n            insert_query_2 = \"\"\"\n                INSERT INTO another_table (field4, field5)\n                VALUES (?, ?)\n            \"\"\"\n            cursor.execute(insert_query_2, (field4, field5))\n\n        # commit once\n        conn.commit()\n\nexcept Exception as e:\n    print(f\"Database operation failed: {e}\")\n    conn.rollback()\n```\n\nBut what if you don't have all the information needed to commit concurrently in a single script?\nFor instance, if your program collects data across dozens of scripts - there is no opportunity to commit everything at once.\n\nInstead, you can call a stable class into each relevant script, and append the query you want to commit.\nThen, at some later point in the program, you loop over that list and write the queries to the database.\n\n```{python}\n#| eval: false\n# define this class in a helper module\nclass QueryCollector:\n    def __init__(self):\n        self.queries = []\n\n    def add(self, query, params):\n        self.queries.append((query, params))\n\n    def execute_all(self, conn_str):\n        try:\n            with pyodbc.connect(conn_str) as conn:\n                with conn.cursor() as cursor:\n                    for query, params in self.queries:\n                        cursor.execute(query, params)\n                conn.commit()\n        except Exception as e:\n            print(f\"Error during batched SQL execution: {e}\")\n            conn.rollback()\n\n\n# call the class in any script that needs it\ncollector = QueryCollector()\n\ncollector.add(\n    \"INSERT INTO some_table (field1, field2, field3) VALUES (?, ?, ?)\",\n    (field1, field2, field3)\n)\n\n\n# commit everything at a later point in the program, once you collected all your queries\ncollector.execute_all(os.getenv(\"sql_connection_string\"))\n```\n\nNow you have a centralized solution which is easy to expand. For example, you can add complex error handling, query-level logging, retries, or group commits to reduce I/O.”"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.40","theme":["cosmo","brand"],"title-block-banner":true,"title":"Robust SQL calls from Python","author":"Dekel Wainer","date":"2025-05-29","categories":["SQL","Python","reliability"],"image":"image.png"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}